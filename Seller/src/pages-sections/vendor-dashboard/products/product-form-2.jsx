// In ProductForm2.jsx

//========================================================================
// Create Product Form 2
//========================================================================

import styles from './styles';
import SymTextField from './components/SymTextField';
import ProductVariantsTable from "./components/ProductVariantsTable";
import ProductImageUploader from './components/ProductImageUploader';
import ProductModelUploader from './components/ProductModelUploader';

import { arrayMove } from "react-sortable-hoc";
import { Box, Card } from "@mui/material"; 
import { uploadFileToBackend, uploadProductModel } from '@/services/productService';
import { useState, useCallback, useMemo, forwardRef, useImperativeHandle } from "react";

//========================================================================

const validateField = (name, value) => {
    let error = "";
    return error;
};

//========================================================================

const ProductForm2 = forwardRef((props, ref) => {
    const { 
        initialValues, 
        handleFormSubmit,
        selectedColors, // This contains { name, hex } from the parent
        selectedSizes,
        setParentVariants,
    } = props;

    // Add this constant definition near the top of ProductForm2.jsx
    const DEFAULT_COLOR_KEY = 'No Color/Default';

    // =============================================================================
    // â­ 1. INITIALIZATION HELPERS (Maps and Lookups) â­
    // =============================================================================

    // Map: Color Hex Code -> Color Name (for media transformation)
    const colorCodeToNameMap = useMemo(() => {
        return selectedColors.reduce((acc, color) => {
            acc[color.hex.toLowerCase()] = color.name.toLowerCase();
            return acc;
        }, {});
    }, [selectedColors]);
    
    // Map: Color/Size Key -> Initial Variant Object (for ID preservation)
    const initialVariantIdMap = useMemo(() => {
        const variantsData = initialValues.variants || [];
        const variantsArray = Array.isArray(variantsData) 
            ? variantsData 
            : Object.values(variantsData);
            
        const map = variantsArray.reduce((acc, variant) => {
            // â­ CRITICAL FIX: Handle null color from API
            const colorName = variant.color?.name || variant.color || DEFAULT_COLOR_KEY; // ðŸ‘ˆ CRITICAL EDIT
            const sizeName = variant.size?.size || variant.size; 
            
            // Key must exactly match the key generated by the ProductVariantsTable
            const key = `${colorName}-${sizeName || 'null'}`; // ðŸ‘ˆ CRITICAL EDIT: Include '|| null' for size in the key
            
            acc[key] = {
                // â­ Ensure ID is available in the initial state object
                id: variant.id, 
                color: colorName, // This will be 'No Color/Default'
                size: sizeName,   // This will be '43-inch'
                price: variant.price || 0,
                salePrice: variant.salePrice || 0,
                supply: variant.stock || 0,
            };
            return acc;
        }, {});
       
        return map;
    }, [initialValues.variants]); // Note: This dependency is likely stable enough
    
    // ProductForm2, around Line 57:
    // Helper: Map initial array/object variants into the required key-value structure
    const initialVariantsMap = useMemo(() => {
        const variantsData = initialValues.variants || [];

        const variantsArray = Array.isArray(variantsData) 
            ? variantsData 
            : Object.values(variantsData);
            
        const map = variantsArray.reduce((acc, variant) => {
            // â­ CRITICAL FIX: Access the name/size from the nested objects
            const colorName = variant.color?.name || variant.color; // Fallback for safety
            const sizeName = variant.size?.size || variant.size; 
            
            const key = `${colorName}-${sizeName}`; 

            // NOTE: The variants state in ProductForm2 holds the raw data 
            // until the table updates it. Let's ensure the initial state 
            // object also contains the ID for the table to use internally.
            
            acc[key] = {
                // â­ Ensure ID is available in the initial state object
                id: variant.id, 
                color: colorName,
                size: sizeName,
                price: variant.price || 0,
                salePrice: variant.salePrice || 0,
                supply: variant.stock || 0, // Map stock to supply
                cost: variant.cost || 0,
                profit: variant.profit || 0,
                material: variant.material || '',
                dimensions: variant.dimensions,
                sizeChartFile: variant.sizeChart,
            };
            return acc;
        }, {});

        return map;
    }, [initialValues.variants]);


    // =============================================================================
    // â­ 2. INITIALIZE STATE (Media Transformation) â­
    // =============================================================================
    
    const initialVariantImages = useMemo(() => {
        const images = initialValues.images || []; 
        return (images).reduce((acc, img) => {
            const colorCode = img.colorCode ? img.colorCode.toLowerCase() : null;
            const colorName = colorCodeToNameMap[colorCode]; 
            
            if (img.url && colorName) {
                acc[colorName] = [...(acc[colorName] || []), img.url];
            }
            return acc;
        }, {});
    }, [initialValues.images, colorCodeToNameMap]);


    const initialVariantModels = useMemo(() => {
        const models = initialValues.threeDModels || []; 
        return (models).reduce((acc, model) => {
            const colorCode = model.colorCode ? model.colorCode.toLowerCase() : null;
            const colorName = colorCodeToNameMap[colorCode]; 
            
            if (model.url && colorName) {
                const lowerCaseName = colorName.toLowerCase();
                acc[lowerCaseName] = [...(acc[lowerCaseName] || []), model.url];
            }
            return acc;
        }, {});
    }, [initialValues.threeDModels, colorCodeToNameMap]);

    const [formValues, setFormValues] = useState(() => ({
        ...initialValues,
        variants: initialValues.variants || [], 
    }));

    const [errors, setErrors] = useState({});
    const [touched, setTouched] = useState({});

    // â­ Initialize media state 
    const [variantImages, setVariantImages] = useState(initialVariantImages);
    const [variantModels, setVariantModels] = useState(initialVariantModels); 
    const [selectedImage, setSelectedImage] = useState(null); 

    // FIX: Initialize variants with the correctly mapped object structure
    const [variants, setVariants] = useState(initialVariantsMap); 

    // ----------------------------------------------------------------------------------
    // 3. IMAGE/MODEL UPLOAD LOGIC 
    // ----------------------------------------------------------------------------------
    
    const handleFileUpload = useCallback(async (acceptedFiles, colorName, uploadService, setStateFunc, isModel = false) => {
        const lowerCaseName = colorName.toLowerCase();
        
        const filesWithPreviews = acceptedFiles.map(file => 
            Object.assign(file, { preview: URL.createObjectURL(file), isUploading: true })
        );
        
        setStateFunc(prev => {
            const existingPermanentFiles = (prev[lowerCaseName] || []).filter(item => typeof item === 'string');
            return { ...prev, [lowerCaseName]: [...existingPermanentFiles, ...filesWithPreviews] };
        });
        
        try {
            const productId = isModel ? (formValues.id || 'temp') : null;
            const uploadPromises = acceptedFiles.map(file => 
                uploadService(file, productId)
            );
            
            const uploadedUrls = await Promise.all(uploadPromises);
            
            setStateFunc(prev => {
                const existingPermanentFiles = (prev[lowerCaseName] || []).filter(item => typeof item === 'string');
                return { ...prev, [lowerCaseName]: [...existingPermanentFiles, ...uploadedUrls] };
            });
            
            filesWithPreviews.forEach(file => URL.revokeObjectURL(file.preview));

        } catch (error) {
            console.error(`Failed to upload ${isModel ? 'models' : 'images'} for ${colorName}:`, error);
            setStateFunc(prev => ({
                ...prev,
                [lowerCaseName]: (prev[lowerCaseName] || []).filter(item => typeof item === 'string')
            }));
        }
    }, [formValues.id]);

    const handleDropUploadAndUpdateState = useCallback((acceptedFiles, colorName) => {
        handleFileUpload(acceptedFiles, colorName, uploadFileToBackend, setVariantImages, false);
    }, [handleFileUpload]);

    const handleModelDropUploadAndUpdateState = useCallback((acceptedFiles, colorName) => {
        handleFileUpload(acceptedFiles, colorName, uploadProductModel, setVariantModels, true);
    }, [handleFileUpload]);

    // --- FORM HANDLERS & UTILITY HANDLERS (Omitted for brevity, they remain correct) ---
    
    const handleChange = useCallback((e) => {
        e.persist();
        const { name, value } = e.target;
        setFormValues(prev => ({ ...prev, [name]: value }));
        
        if (touched[name]) {
            const error = validateField(name, value);
            setErrors(prev => ({ ...prev, [name]: error }));
        }
    }, [touched]);

    const handleBlur = useCallback((e) => {
        const { name, value } = e.target;
        setTouched(prev => ({ ...prev, [name]: true }));
        
        const error = validateField(name, value);
        setErrors(prev => ({ ...prev, [name]: error }));
    }, []);

    const onSortEndUtility = useCallback((filesArray, oldIndex, newIndex) => arrayMove(filesArray, oldIndex, newIndex), []);

    const handleClick = useCallback((index) => setSelectedImage(index), []);

    const handleVariantDelete = useCallback((colorName, urlToDelete) => {
        const lowerCaseName = colorName.toLowerCase();
        setVariantImages(prev => ({
            ...prev,
            [lowerCaseName]: (prev[lowerCaseName] || []).filter(item => item !== urlToDelete)
        }));
    }, []);

    const handleVariantSortEnd = useCallback((colorName, { oldIndex, newIndex }) => {
        const lowerCaseName = colorName.toLowerCase();
        setVariantImages(prev => {
            const currentFiles = prev[lowerCaseName] || [];
            const sortedFiles = onSortEndUtility(currentFiles, oldIndex, newIndex);
            return { ...prev, [lowerCaseName]: sortedFiles };
        });
    }, [onSortEndUtility]);

    const handleModelDelete = useCallback((colorName, fileKeyToDelete) => {
        const lowerCaseName = colorName.toLowerCase();
        setVariantModels(prev => {
            const currentFiles = prev[lowerCaseName] || [];
            const updatedFiles = currentFiles.filter(item => {
                if (typeof item === 'string') return item !== fileKeyToDelete;
                if (item && item.preview) return item.preview !== fileKeyToDelete;
                return true;
            });
            return { ...prev, [lowerCaseName]: updatedFiles };
        });
    }, []);

    const handleModelSortEnd = useCallback((colorName, { oldIndex, newIndex }) => {
        const lowerCaseName = colorName.toLowerCase();
        setVariantModels(prev => {
            const currentFiles = prev[lowerCaseName] || [];
            const sortedFiles = onSortEndUtility(currentFiles, oldIndex, newIndex);
            return { ...prev, [lowerCaseName]: sortedFiles };
        });
    }, [onSortEndUtility]);

    // --- DYNAMICALLY BUILD THE imageHandlerMap & modelHandlerMap (Omitted for brevity) ---
    const imageHandlerMap = useMemo(() => {
        return selectedColors.reduce((map, colorVariantObject) => {
            const colorName = colorVariantObject.name;
            const lowerCaseName = colorName.toLowerCase();
            map[lowerCaseName] = { files: variantImages[lowerCaseName] || [], handleDrop: (acceptedFiles) => handleDropUploadAndUpdateState(acceptedFiles, colorName), handleDelete: (urlToDelete) => handleVariantDelete(colorName, urlToDelete), handleSortEnd: (sortProps) => handleVariantSortEnd(colorName, sortProps), selectedImage: selectedImage, handleClick: handleClick };
            return map;
        }, {});
    }, [selectedColors, variantImages, selectedImage, handleClick, handleVariantDelete, handleVariantSortEnd, handleDropUploadAndUpdateState]); 

    const modelHandlerMap = useMemo(() => {
        return selectedColors.reduce((map, colorVariantObject) => {
            const colorName = colorVariantObject.name;
            const lowerCaseName = colorName.toLowerCase();
            map[lowerCaseName] = { files: variantModels[lowerCaseName] || [], handleDrop: (acceptedFiles) => handleModelDropUploadAndUpdateState(acceptedFiles, colorName), handleDelete: (urlToDelete) => handleModelDelete(colorName, urlToDelete), handleSortEnd: (sortProps) => handleModelSortEnd(colorName, sortProps) };
            return map;
        }, {});
    }, [selectedColors, variantModels, handleModelDelete, handleModelSortEnd, handleModelDropUploadAndUpdateState]);


    // â­ 6. Expose handleSubmit via ref
    useImperativeHandle(ref, () => ({
        submit: handleSubmit,
    }));

    // =========================================================================
    // â­ TRANSFORMER FUNCTION â­
    // =========================================================================
    const getTransformedVariantsForAPI = useCallback((currentRawVariantValues) => {

        return Object.values(currentRawVariantValues).map(v => {
            const priceValue = parseFloat(v.price) || 0;
            const salePriceValue = parseFloat(v.salePrice) || 0;
            const costValue = parseFloat(v.cost) || 0;
            const stockValue = parseInt(v.supply) || 0;
            const materialValue = v.material || "";

            return {
                "id": v.id, 
                "price": priceValue,
                "stock": stockValue, 
                "salePrice": salePriceValue,
                "cost": costValue,
                "material": materialValue
            };
        });
    }, []);

    // ----------------------------------------------------------------------------------
    // â­ HANDLER: Logic to receive variants from table and re-inject IDs (LOOP PREVENTION FIX) â­
    // ----------------------------------------------------------------------------------
    const handleVariantsTableChange = useCallback((newVariantsFromTable) => {

        const variantsWithIds = {};
        
        Object.entries(newVariantsFromTable).forEach(([key, variantData]) => {
            // Lookup the initial variant using the key (e.g., "RED-22 inch")
            const initialVariant = initialVariantIdMap[key];
                        
            variantsWithIds[key] = {
                ...variantData,
                // CRITICAL: Preserve the ID. This is where it gets the ID from the map.
                id: initialVariant ? initialVariant.id : null, 
            };
        });

        // CRITICAL LOOP PREVENTION: Check deep equality before setting state
        const currentVariantsString = JSON.stringify(variants);
        const newVariantsString = JSON.stringify(variantsWithIds);

        if (currentVariantsString !== newVariantsString) {
            setVariants(variantsWithIds);
            setParentVariants(variantsWithIds);
        }
    }, [initialVariantIdMap, setParentVariants, variants]); // Must include 'variants' state
    
    // ----------------------------------------------------------------------------------
    // 5. SUBMISSION HANDLER
    // ----------------------------------------------------------------------------------
    const handleSubmit = useCallback((e) => {
        if (e && typeof e.preventDefault === 'function') {
            e.preventDefault();
        }
        
        const fieldsToCheck = []; 
        let newErrors = {};
        let formIsValid = true;

        fieldsToCheck.forEach(name => {
            const value = formValues[name];
            const error = validateField(name, value);
            if (error) {
                newErrors[name] = error;
                formIsValid = false;
            }
        });

        const newTouched = fieldsToCheck.reduce((acc, name) => ({ ...acc, [name]: true }), {});
        setTouched(prev => ({ ...prev, ...newTouched }));
        setErrors(newErrors);

        if (formIsValid) {

            const finalVariantsForAPI = getTransformedVariantsForAPI(variants);
            
            const transformMedia = (mediaState) => {
                return Object.entries(mediaState).flatMap(([colorKey, urls]) => {
                    const colorVariant = selectedColors.find(c => c.name.toLowerCase() === colorKey);
                    const colorCode = colorVariant ? colorVariant.hex : '#FFFFFF'; 

                    return urls.filter(item => typeof item === 'string').map(url => ({
                        url: url,
                        colorCode: colorCode,
                        colorName: colorVariant ? colorVariant.name : colorKey,
                    }));
                });
            };

            const allProductImages = transformMedia(variantImages);
            
            const allProductModels = transformMedia(variantModels).map(({ url, colorCode }) => ({
                url, 
                colorCode
            }));

            const finalData = {
                ...formValues,
                productImages: allProductImages, 
                threeDModels: allProductModels,
                variants: finalVariantsForAPI,
            };
            
            handleFormSubmit(finalData);
        }
    }, [formValues, handleFormSubmit, variants, variantImages, variantModels, selectedColors, getTransformedVariantsForAPI]);


    return (
        <form onSubmit={handleSubmit}>
            <Card sx={{ ...styles.leftCard, mb: 3 }}>

                {/* Product Variants Table */}
                {!(selectedColors.length === 0 && selectedSizes.length === 0) ? (
                        <ProductVariantsTable
                            initialVariants={initialValues.variants || []}
                            colors={selectedColors.map((color) => color.name)}
                            sizes={selectedSizes.map((size) => size.name)}
                            onVariantsChange={handleVariantsTableChange} 
                        />
                    ) : null
                }
                
                <Box sx={{ display: 'flex', flexDirection: 'column', gap: 3 }}>
                    
                    {/* IMAGES */}
                    <ProductImageUploader
                        colorVariants={selectedColors}
                        imageHandlerMap={imageHandlerMap}
                    />

                    {/* 3D MODELS SECTION */}
                    <ProductModelUploader
                        colorVariants={selectedColors}
                        modelHandlerMap={modelHandlerMap}
                    />

                </Box>
            </Card>
        </form>
    );
});

export default ProductForm2;